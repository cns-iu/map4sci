{"version":3,"sources":["mapboxgl-minimap.js","index.ts"],"names":["Minimap","blankStyle","sources","_options","options","Object","assign","_ticking","_lastMouseMoveEvent","_parentMap","_isDragging","_isCursorOverFeature","_previousPoint","_currentPoint","_trackingRectCoordinates","parentMap","opts","container","_container","_createContainer","miniMap","_miniMap","mapboxgl","Map","attributionControl","style","zoom","center","maxBounds","setMaxBounds","on","_load","bind","forEach","i","disable","zoomAdjust","_zoomAdjust","bounds","getBounds","_convertBoundsToPoints","addSource","addLayer","clusters","nodes","edgeColor","edgeWidth","edgeOpacity","fillColor","fillOpacity","_trackingRect","getSource","_update","_mouseMove","_mouseDown","_mouseUp","_miniMapCanvas","getCanvasContainer","addEventListener","_preventDefault","e","lngLat","lng","lat","features","queryRenderedFeatures","point","layers","length","cursor","offset","newBounds","_moveTrackingRect","fitBounds","duration","noMoveStart","source","data","_data","properties","_ne","_sw","setData","ne","sw","trc","parentBounds","_setTrackingRectBounds","miniZoom","parseInt","getZoom","parentZoom","levels","zoomLevels","found","setZoom","setCenter","getCenter","document","createElement","className","setAttribute","width","height","containerStyles","getContainer","appendChild","id","preventDefault"],"mappings":"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","file":"visualization.96c3d255.js","sourceRoot":"../../../../../src/visualization","sourcesContent":["/*\n\thttps://github.com/brendanmatkin/mapboxgl-minimap\n*/\nconst blankStyle = {\n\t'version': 8,\n\t'name': 'Blank',\n\t'center': [\n\t\t0,\n\t\t0\n\t],\n\t'zoom': 0,\n\t'sources': {},\n\t'sprite': 'https://cdn.jsdelivr.net/gh/lukasmartinelli/osm-liberty@gh-pages/sprites/osm-liberty',\n\t'glyphs': 'https://cdn.jsdelivr.net/gh/orangemug/font-glyphs@gh-pages/glyphs/{fontstack}/{range}.pbf',\n\t'layers': [\n\t\t{\n\t\t\t'id': 'background',\n\t\t\t'type': 'background',\n\t\t\t'paint': {\n\t\t\t\t'background-color': 'rgba(255,255,255,1)'\n\t\t\t}\n\t\t}\n\t]\n};\nclass Minimap {\n\tconstructor(sources, _options) {\n\t\tthis.sources = sources;\n\t\tthis.options = _options;\n\t\tObject.assign(this.options, _options);\n\n\t\tthis._ticking = false;\n\t\tthis._lastMouseMoveEvent = null;\n\t\tthis._parentMap = null;\n\t\tthis._isDragging = false;\n\t\tthis._isCursorOverFeature = false;\n\t\tthis._previousPoint = [0, 0];\n\t\tthis._currentPoint = [0, 0];\n\t\tthis._trackingRectCoordinates = [[[], [], [], [], []]];\n\t}\n\n\tonAdd(parentMap) {\n\t\tthis._parentMap = parentMap;\n\n\t\tvar opts = this.options;\n\t\tvar container = this._container = this._createContainer(parentMap);\n\t\tvar miniMap = this._miniMap = new mapboxgl.Map({\n\t\t\tattributionControl: false,\n\t\t\tcontainer: container,\n\t\t\tstyle: blankStyle,\n\t\t\tzoom: opts.zoom,\n\t\t\tcenter: opts.center\n\t\t});\n\n\t\tif (opts.maxBounds) miniMap.setMaxBounds(opts.maxBounds);\n\n\t\tminiMap.on('load', this._load.bind(this));\n\n\t\treturn this._container;\n\t}\n\n\tonRemove(parentMap) {\n\t\treturn;\n\t}\n\n\t_load() {\n\t\tvar opts = this.options;\n\t\tvar parentMap = this._parentMap;\n\t\tvar miniMap = this._miniMap;\n\t\tvar interactions = [\n\t\t\t'dragPan', 'scrollZoom', 'boxZoom', 'dragRotate',\n\t\t\t'keyboard', 'doubleClickZoom', 'touchZoomRotate'\n\t\t];\n\n\t\tinteractions.forEach(function (i) {\n\t\t\tif (opts[i] !== true) {\n\t\t\t\tminiMap[i].disable();\n\t\t\t}\n\t\t});\n\n\t\tif (typeof opts.zoomAdjust === 'function') {\n\t\t\tthis.options.zoomAdjust = opts.zoomAdjust.bind(this);\n\t\t} else if (opts.zoomAdjust === null) {\n\t\t\tthis.options.zoomAdjust = this._zoomAdjust.bind(this);\n\t\t}\n\n\t\tvar bounds = miniMap.getBounds();\n\n\t\tthis._convertBoundsToPoints(bounds);\n\n\t\tminiMap.addSource('trackingRect', {\n\t\t\t'type': 'geojson',\n\t\t\t'data': {\n\t\t\t\t'type': 'Feature',\n\t\t\t\t'properties': {\n\t\t\t\t\t'name': 'trackingRect'\n\t\t\t\t},\n\t\t\t\t'geometry': {\n\t\t\t\t\t'type': 'Polygon',\n\t\t\t\t\t'coordinates': this._trackingRectCoordinates\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// Add the geojson layers of our data so the minimap matches the parent map\n\t\tminiMap.addLayer({\n\t\t\t'id': 'cluster',\n\t\t\t'type': 'fill',\n\t\t\t'source': { 'type': 'geojson', 'data': this.sources.clusters },\n\t\t\t'layout': {},\n\t\t\t'paint': {\n\t\t\t\t'fill-color': ['get', 'fill'],\n\t\t\t\t'fill-opacity': 0.7,\n\t\t\t\t'fill-outline-color': ['get', 'stroke']\n\t\t\t},\n\t\t});\n\t\tminiMap.addLayer({\n\t\t\t'id': 'cluster_boundary',\n\t\t\t'type': 'line',\n\t\t\t'minzoom': 2,\n\t\t\t'source': { 'type': 'geojson', 'data': this.sources.clusters },\n\t\t\t'layout': {},\n\t\t\t'paint': {\n\t\t\t\t'line-color': ['get', 'stroke'],\n\t\t\t\t'line-width': 0.5,\n\t\t\t\t'line-opacity': 0.8\n\t\t\t},\n\t\t});\n\t\tminiMap.addLayer({\n\t\t\t'id': 'node_labels',\n\t\t\t'type': 'symbol',\n\t\t\t'minzoom': 2,\n\t\t\t'source': { 'type': 'geojson', 'data': this.sources.nodes },\n\t\t\t'layout': {\n\t\t\t\t'text-field': '{label}',\n\t\t\t\t'text-font': ['Open Sans Regular'],\n\t\t\t\t'text-size': 14,\n\t\t\t\t'text-anchor': 'center',\n\t\t\t\t'text-justify': 'center',\n\t\t\t\t'text-allow-overlap': false\n\n\t\t\t},\n\t\t\t'filter': ['==', 'level', 1]\n\t\t});\n\t\tminiMap.addLayer({\n\t\t\t'id': 'node_labels_2',\n\t\t\t'type': 'symbol',\n\t\t\t'minzoom': 3,\n\t\t\t'source': { 'type': 'geojson', 'data': this.sources.nodes },\n\t\t\t'layout': {\n\t\t\t\t'text-field': '{label}',\n\t\t\t\t'text-font': ['Open Sans Regular'],\n\t\t\t\t'text-size': 9,\n\t\t\t\t'text-anchor': 'center',\n\t\t\t\t'text-justify': 'center'\n\t\t\t},\n\t\t\t'filter': ['all',\n\t\t\t\t['<=', 'level', 3],\n\t\t\t\t['>', 'level', 1]\n\t\t\t]\n\t\t});\n\n\t\tminiMap.addLayer({\n\t\t\t'id': 'trackingRectOutline',\n\t\t\t'type': 'line',\n\t\t\t'source': 'trackingRect',\n\t\t\t'layout': {},\n\t\t\t'paint': {\n\t\t\t\t'line-color': opts.edgeColor,\n\t\t\t\t'line-width': opts.edgeWidth,\n\t\t\t\t'line-opacity': opts.edgeOpacity\n\t\t\t}\n\t\t});\n\n\t\t// needed for dragging\n\t\tminiMap.addLayer({\n\t\t\t'id': 'trackingRectFill',\n\t\t\t'type': 'fill',\n\t\t\t'source': 'trackingRect',\n\t\t\t'layout': {},\n\t\t\t'paint': {\n\t\t\t\t'fill-color': opts.fillColor,\n\t\t\t\t'fill-opacity': opts.fillOpacity\n\t\t\t}\n\t\t});\n\n\t\tthis._trackingRect = this._miniMap.getSource('trackingRect');\n\n\t\tthis._update();\n\n\t\tparentMap.on('move', this._update.bind(this));\n\n\t\tminiMap.on('mousemove', this._mouseMove.bind(this));\n\t\tminiMap.on('mousedown', this._mouseDown.bind(this));\n\t\tminiMap.on('mouseup', this._mouseUp.bind(this));\n\n\t\tminiMap.on('touchmove', this._mouseMove.bind(this));\n\t\tminiMap.on('touchstart', this._mouseDown.bind(this));\n\t\tminiMap.on('touchend', this._mouseUp.bind(this));\n\n\t\tthis._miniMapCanvas = miniMap.getCanvasContainer();\n\t\tthis._miniMapCanvas.addEventListener('wheel', this._preventDefault);\n\t\tthis._miniMapCanvas.addEventListener('mousewheel', this._preventDefault);\n\t}\n\n\t_mouseDown(e) {\n\t\tif (this._isCursorOverFeature) {\n\t\t\tthis._isDragging = true;\n\t\t\tthis._previousPoint = this._currentPoint;\n\t\t\tthis._currentPoint = [e.lngLat.lng, e.lngLat.lat];\n\t\t}\n\t}\n\n\t_mouseMove(e) {\n\t\tthis._ticking = false;\n\n\t\tvar miniMap = this._miniMap;\n\t\tvar features = miniMap.queryRenderedFeatures(e.point, {\n\t\t\tlayers: ['trackingRectFill']\n\t\t});\n\n\t\t// don't update if we're still hovering the area\n\t\tif (!(this._isCursorOverFeature && features.length > 0)) {\n\t\t\tthis._isCursorOverFeature = features.length > 0;\n\t\t\tthis._miniMapCanvas.style.cursor = this._isCursorOverFeature ? 'move' : '';\n\t\t}\n\n\t\tif (this._isDragging) {\n\t\t\tthis._previousPoint = this._currentPoint;\n\t\t\tthis._currentPoint = [e.lngLat.lng, e.lngLat.lat];\n\n\t\t\tvar offset = [\n\t\t\t\tthis._previousPoint[0] - this._currentPoint[0],\n\t\t\t\tthis._previousPoint[1] - this._currentPoint[1]\n\t\t\t];\n\n\t\t\tvar newBounds = this._moveTrackingRect(offset);\n\n\t\t\tthis._parentMap.fitBounds(newBounds, {\n\t\t\t\tduration: 80,\n\t\t\t\tnoMoveStart: true\n\t\t\t});\n\t\t}\n\t}\n\n\t_mouseUp() {\n\t\tthis._isDragging = false;\n\t\tthis._ticking = false;\n\t}\n\n\t_moveTrackingRect(offset) {\n\t\tvar source = this._trackingRect;\n\t\tvar data = source._data;\n\t\tvar bounds = data.properties.bounds;\n\n\t\tbounds._ne.lat -= offset[1];\n\t\tbounds._ne.lng -= offset[0];\n\t\tbounds._sw.lat -= offset[1];\n\t\tbounds._sw.lng -= offset[0];\n\n\t\tthis._convertBoundsToPoints(bounds);\n\t\tsource.setData(data);\n\n\t\treturn bounds;\n\t}\n\n\t_setTrackingRectBounds(bounds) {\n\t\tvar source = this._trackingRect;\n\t\tvar data = source._data;\n\n\t\tdata.properties.bounds = bounds;\n\t\tthis._convertBoundsToPoints(bounds);\n\t\tsource.setData(data);\n\t}\n\n\t_convertBoundsToPoints(bounds) {\n\t\tvar ne = bounds._ne;\n\t\tvar sw = bounds._sw;\n\t\tvar trc = this._trackingRectCoordinates;\n\n\t\ttrc[0][0][0] = ne.lng;\n\t\ttrc[0][0][1] = ne.lat;\n\t\ttrc[0][1][0] = sw.lng;\n\t\ttrc[0][1][1] = ne.lat;\n\t\ttrc[0][2][0] = sw.lng;\n\t\ttrc[0][2][1] = sw.lat;\n\t\ttrc[0][3][0] = ne.lng;\n\t\ttrc[0][3][1] = sw.lat;\n\t\ttrc[0][4][0] = ne.lng;\n\t\ttrc[0][4][1] = ne.lat;\n\t}\n\n\t_update() {\n\t\tif (this._isDragging) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar parentBounds = this._parentMap.getBounds();\n\n\t\tthis._setTrackingRectBounds(parentBounds);\n\n\t\tif (typeof this.options.zoomAdjust === 'function') {\n\t\t\tthis.options.zoomAdjust();\n\t\t}\n\t}\n\n\t_zoomAdjust() {\n\t\tvar miniMap = this._miniMap;\n\t\tvar parentMap = this._parentMap;\n\t\tvar miniZoom = parseInt(miniMap.getZoom(), 10);\n\t\tvar parentZoom = parseInt(parentMap.getZoom(), 10);\n\t\tvar levels = this.options.zoomLevels;\n\t\tvar found = false;\n\n\t\tlevels.forEach(function (zoom) {\n\t\t\tif (!found && parentZoom >= zoom[0]) {\n\t\t\t\tif (miniZoom >= zoom[1]) {\n\t\t\t\t\tminiMap.setZoom(zoom[2]);\n\t\t\t\t}\n\n\t\t\t\tminiMap.setCenter(parentMap.getCenter());\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t});\n\n\t\tif (!found && miniZoom !== this.options.zoom) {\n\t\t\tif (typeof this.options.bounds === 'object') {\n\t\t\t\tminiMap.fitBounds(this.options.bounds, { duration: 50 });\n\t\t\t}\n\n\t\t\tminiMap.setZoom(this.options.zoom);\n\t\t}\n\t}\n\n\t_createContainer(parentMap) {\n\t\tvar opts = this.options;\n\t\tvar container = document.createElement('div');\n\n\t\tcontainer.className = 'mapboxgl-ctrl-minimap mapboxgl-ctrl';\n\t\tcontainer.setAttribute('style', 'width: ' + opts.width + '; height: ' + opts.height + '; ' + opts.containerStyles);\n\t\tcontainer.addEventListener('contextmenu', this._preventDefault);\n\n\t\tparentMap.getContainer().appendChild(container);\n\n\t\tif (opts.id !== '') {\n\t\t\tcontainer.id = opts.id;\n\t\t}\n\n\t\treturn container;\n\t}\n\n\t_preventDefault(e) {\n\t\te.preventDefault();\n\t}\n}\n\nexport default Minimap;","import MiniMap from './mapboxgl-minimap.js';\ndeclare global {\n    interface Window { mapboxgl: any; }\n}\ndeclare module mapboxgl {\n    export type Style = any;\n    export type Map = any;\n    export type Layer = any;\n}\nconst mapboxgl = window.mapboxgl as any;\n\n/* @TODO:\n    use node size when it get's added to workflow\n    ------------------------------------------------------------------------------------------------------------\n    future: could create a scimap2020Map function which does zmltMap + more customization (like specific popups)\n    future: push to NPM\n*/\n\n\ninterface Edge {\n    level: number,\n    zoom: number,\n    color: string,\n    width: number,\n    opacity: number,\n    borderOpacity: number,\n    borderColor: string,\n    borderWidth: number\n}\ninterface Node {\n    level: number,\n    zoom: number,\n    fontSize: number\n}\ninterface Cluster {\n    fillOpacity: number,\n    borderLineWidth: number,\n    borderLineOpacity: number,\n    borderLineMinZoom: number\n}\n\ntype ZoomLevel = [number, number, number];\ninterface MiniMapOptions {\n    id: number | string,\n    width: string,\n    height: string,\n    style: mapboxgl.Style,\n    center: [number, number],\n    zoom: number,\n    containerStyles: string,\n    zoomAdjust: null | Function,\n    zoomLevels: ZoomLevel[],\n    edgeColor: string,\n    edgeWidth: number,\n    edgeOpacity: number,\n    fillColor: string,\n    fillOpacity: number,\n    dragPan: boolean,\n    scrollZoom: boolean,\n    boxZoom: boolean,\n    dragRotate: boolean,\n    keyboard: boolean,\n    doubleClickZoom: boolean,\n    touchZoomRotate: boolean\n}\n\ntype PopupContent = (string | [string, Function])[];\ninterface Popup {\n    layer: string,\n    content: PopupContent\n}\ninterface Sources {\n    nodes: string,\n    edges: string,\n    clusters: string,\n    clusterBoundaries: string,\n    allEdges?: string\n}\ninterface Configuration {\n    minZoom: number,\n    maxZoom: number,\n    initialZoom: number,\n    textOverlapEnabledZoom: number,\n    sources: Sources,\n    edges: Edge[],\n    nodes: Node[],\n    clusters: Cluster,\n    popups?: Popup[],\n    minimapOptions?: any\n}\n\nconst blankStyle: mapboxgl.Style = {\n    'version': 8,\n    'name': 'Blank',\n    'center': [\n        0,\n        0\n    ],\n    'zoom': 0,\n    'sources': {},\n    'sprite': 'https://cdn.jsdelivr.net/gh/lukasmartinelli/osm-liberty@gh-pages/sprites/osm-liberty',\n    'glyphs': 'https://cdn.jsdelivr.net/gh/orangemug/font-glyphs@gh-pages/glyphs/{fontstack}/{range}.pbf',\n    'layers': [\n        {\n            'id': 'background',\n            'type': 'background',\n            'paint': {\n                'background-color': 'rgba(255,255,255,1)'\n            }\n        }\n    ]\n};\nconst defaultMinimapOptions: MiniMapOptions = {\n    id: 'mapboxgl-minimap',\n    width: '320px',\n    height: '180px',\n    style: blankStyle,\n    center: [0, 0],\n    zoom: 0,\n\n    containerStyles: `\n        border: 1px solid lightgray; \n        border-radius: 5px; \n        -webkit-box-shadow: 3px 3px 5px 4px #00000021; \n        -moz-box-shadow: 3px 3px 5px 4px #00000021; \n        box-shadow: 3px 3px 5px 4px #00000021;\n    `,\n\n    // should be a function; will be bound to Minimap\n    zoomAdjust: null,\n\n    // [a, b, c]\n    // if parent map zoom >= a, and minimap zoom >= b, set minimap zoom to c\n    // must be defined from most zoomed in rule, to least zoomed in rule.\n    zoomLevels: [\n        [9, 3, 4],\n        [8, 2, 3],\n        [6, 0, 2]\n    ],\n\n    edgeColor: '#08F',\n    edgeWidth: 1,\n    edgeOpacity: 1,\n\n    fillColor: '#F80',\n    fillOpacity: 0.25,\n\n    dragPan: false,\n    scrollZoom: false,\n    boxZoom: false,\n    dragRotate: false,\n    keyboard: false,\n    doubleClickZoom: false,\n    touchZoomRotate: false\n};\nconst defaultNodes: Node[] = [\n    { level: 0, zoom: 0.0, fontSize: 0 },\n    { level: 1, zoom: 0.0, fontSize: 20 },\n    { level: 2, zoom: 4.5, fontSize: 18 },\n    { level: 3, zoom: 5.0, fontSize: 18 },\n    { level: 4, zoom: 5.5, fontSize: 16 },\n    { level: 5, zoom: 6.0, fontSize: 16 },\n    { level: 6, zoom: 6.2, fontSize: 14 },\n    { level: 7, zoom: 6.5, fontSize: 14 },\n    { level: 8, zoom: 6.7, fontSize: 12 },\n    { level: 9, zoom: 7.5, fontSize: 12 },\n];\nconst defaultEdges: Edge[] = [\n    { level: 0, zoom: 0, color: '', width: 0, opacity: 0.0, borderOpacity: 0.0, borderColor: '', borderWidth: 0 },\n    { level: 1, zoom: 1.5, color: '#FFEBA1', width: 3.2, opacity: 1.0, borderOpacity: 1.0, borderColor: 'yellow', borderWidth: 1.2 },\n    { level: 2, zoom: 3.5, color: '#FFEBA1', width: 3, opacity: 1.0, borderOpacity: 1.0, borderColor: '#F9D776', borderWidth: 1 },\n    { level: 3, zoom: 4.5, color: '#F9D776', width: 2.7, opacity: 0.9, borderOpacity: 0.0, borderColor: '#F9D776', borderWidth: 1 },\n    { level: 4, zoom: 5.0, color: '#c1b276', width: 2.7, opacity: 0.9, borderOpacity: 0.0, borderColor: '#F9D776', borderWidth: 1 },\n    { level: 5, zoom: 5.4, color: '#94895f', width: 2.2, opacity: 0.8, borderOpacity: 0.0, borderColor: '#F9D776', borderWidth: 1 },\n    { level: 6, zoom: 5.7, color: '#615b43', width: 2.2, opacity: 0.8, borderOpacity: 0.0, borderColor: '#F9D776', borderWidth: 1 },\n    { level: 7, zoom: 6.0, color: 'gray', width: 2, opacity: 0.7, borderOpacity: 0.0, borderColor: '#F9D776', borderWidth: 1 },\n    { level: 8, zoom: 6.2, color: 'gray', width: 2, opacity: 0.6, borderOpacity: 0.0, borderColor: '#F9D776', borderWidth: 1 },\n    { level: 9, zoom: 7.0, color: 'gray', width: 1, opacity: 0.5, borderOpacity: 0.0, borderColor: '#F9D776', borderWidth: 1 }\n];\nconst defaultClusters: Cluster = {\n    fillOpacity: 0.7,\n    borderLineWidth: 0.5,\n    borderLineOpacity: 0.8,\n    borderLineMinZoom: 3\n};\nconst defaultInitialZoom: number = 2;\nconst defaulTtextOverlapEnabledZoom: number = 3;\nconst defaultMinZoom: number = 0;\nconst defaultMaxZoom: number = 10;\n\nclass ZmltMap {\n    container: string;\n    config: Configuration;\n    sources: Sources;\n    edges: Edge[];\n    nodes: Node[];\n    clusters: Cluster;\n    popups: Popup[];\n    minimapOptions: MiniMapOptions;\n    map: mapboxgl.Map;\n    nodeZoomIndex: number;\n    edgeZoomIndex: number;\n    currentZoom: number;\n    minZoom: number;\n    maxZoom: number;\n    initialZoom: number;\n    textOverlapEnabledZoom: number;\n    textOverlapEnabled: boolean;\n    hoverEdgeID: number | string;\n    hoverNodeID: number | string;\n\n    constructor(container: string, config: Configuration) {\n        if (!container) throw new Error('Container is required to Load() ZmltMap.');\n        if (!config) throw new Error('Configuration object is required for ZmltMap.');\n        if (!config.sources) throw new Error('Sources is a required property of ZmltMap configuration object.');\n        if (!config.sources.nodes) throw new Error('Nodes is missing from the Sources object.');\n        if (!config.sources.edges) throw new Error('Edges is missing from the Sources object.');\n        if (!config.sources.clusters) throw new Error('Clusters is missing from the Sources object.');\n        if (!config.sources.clusterBoundaries) throw new Error('ClusterBoundaries is missing from the Sources object.');\n\n        this.container = container;\n        this.config = config;\n        this.sources = config.sources;\n        this.textOverlapEnabled = false;\n        this.nodeZoomIndex = 0;\n        this.edgeZoomIndex = 0;\n        this.hoverEdgeID = null;\n        this.hoverNodeID = null;\n        this.edges = config.edges ? config.edges : defaultEdges;\n        this.nodes = config.nodes ? config.nodes : defaultNodes;\n        this.clusters = config.clusters ? config.clusters : defaultClusters;\n        this.popups = config.popups ? config.popups : [];\n        this.minimapOptions = config.minimapOptions ? config.minimapOptions : defaultMinimapOptions;\n        this.currentZoom = config.initialZoom ? config.initialZoom : defaultInitialZoom;\n        this.minZoom = config.minZoom ? config.minZoom : defaultMinZoom;\n        this.maxZoom = config.maxZoom ? config.maxZoom : defaultMaxZoom;\n        this.textOverlapEnabledZoom = config.textOverlapEnabledZoom ? config.textOverlapEnabledZoom : defaulTtextOverlapEnabledZoom;\n        this.minimapOptions.style = blankStyle;\n\n        this.load();\n    }\n\n    load(): void {\n        this.map = new mapboxgl.Map({\n            container: this.container,\n            style: blankStyle,\n            center: [-0, 0],\n            zoom: this.currentZoom,\n            maxZoom: this.maxZoom,\n            minZoom: this.minZoom,\n            renderWorldCopies: false,\n            dragRotate: true\n        });\n        this.map.on('load', () => {\n            this.addSources();\n            this.addClusters();\n            this.addEdges();\n            this.addNodes();\n            this.addEdgeHover();\n            this.addNodeHover();\n            this.addUI();\n        });\n    }\n\n    addUI(): void {\n        const { map, popups, sources, minimapOptions } = this;\n\n        // Add zoom controls (without rotation controls) to the map.\n        map.addControl(new mapboxgl.NavigationControl({ showCompass: false }), 'top-left');\n        map.addControl(new MiniMap(sources, minimapOptions), 'bottom-left');\n        map.addControl(new mapboxgl.FullscreenControl());\n        if (popups.length) this.addPopups();\n\n        // When the user zooms the map, this method handles showing and hiding data based on zoom level\n        map.on('zoom', () => this.updateFilters());\n    }\n\n    // In order to show more or less data based on the zoom level we have to update the layer filters when the map zooms.\n    updateFilters(): void {\n        const { map, edges, nodes, textOverlapEnabledZoom, textOverlapEnabled } = this;\n        const currentZoom: number = this.getZoom();\n\n        // When the zoom level changes, check if we need to display a different set of nodes. If we do, update the node filter.\n        if (this.nodeLevelChange()) {\n            const currentNode = ['get', 'zoom', ['at', ['get', 'level'], ['literal', nodes]]];\n            map.setFilter('node_labels', ['>=', currentZoom, currentNode]);\n        }\n\n        // When the zoom level changes, check if we need to display a different set of edges. If we do, update the node filter.\n        // We decided showing the nodes (without labels) at the same time as the edges was preferable, instead of waiting for\n        // when the labels will fit. \n        if (this.edgeLevelChange()) {\n            const currentEdge = ['get', 'zoom', ['at', ['get', 'level'], ['literal', edges]]];\n            map.setFilter('nodes', ['>=', currentZoom, currentEdge]);\n            map.setFilter('edges_border', ['>=', currentZoom, currentEdge]);\n            map.setFilter('edges', ['>=', currentZoom, currentEdge]);\n        }\n\n        //  Determing if text overlap should be enabled or disabled based on the break point set in the config object.\n        if (!textOverlapEnabled && currentZoom > textOverlapEnabledZoom) {\n            map.setLayoutProperty('node_labels', 'text-allow-overlap', true);\n            this.textOverlapEnabled = true;\n        } else if (textOverlapEnabled && currentZoom < textOverlapEnabledZoom) {\n            map.setLayoutProperty('node_labels', 'text-allow-overlap', false);\n            this.textOverlapEnabled = false;\n        }\n    }\n\n    // Returns whether or not the zoom level has changed enough to warrant a change in which nodes we are displaying.\n    nodeLevelChange(): boolean {\n        let currentIndex: number = this.getZoomIndex(this.nodes);\n        if (currentIndex === this.nodeZoomIndex) return false;\n        this.nodeZoomIndex = currentIndex;\n        return true;\n    }\n\n    // Returns whether or not the zoom level has changed enough to warrant a change in which edges we are displaying.\n    edgeLevelChange(): boolean {\n        let currentIndex: number = this.getZoomIndex(this.edges);\n        if (currentIndex === this.edgeZoomIndex) return false;\n        this.edgeZoomIndex = currentIndex;\n        return true;\n    }\n\n    // Converts the current zoom number, to the index number of the object with the same .zoom property in the lookup array passed in. \n    // Used because getZoom() will return very precise values, and the nodes / edges config objects will not match up exactly.\n    getZoomIndex(zoomLookup: object[]): number {\n        const zoom: number = this.getZoom();\n        for (let index = 0; index <= zoomLookup.length; index++) {\n            if (index == (zoomLookup.length - 1)) return index;\n            if (zoom >= zoomLookup[index]['zoom'] && zoom < zoomLookup[index + 1]['zoom']) return index;\n        }\n    }\n\n    addSources(): void {\n        const { map, sources } = this;\n        map.addSource('edges_source', {\n            'type': 'geojson',\n            'data': sources.edges\n        });\n        map.addSource('nodes_source', {\n            'type': 'geojson',\n            'data': sources.nodes\n        });\n        map.addSource('cluster_source', {\n            'type': 'geojson',\n            'data': sources.clusters\n        });\n        map.addSource('cluster_boundary_source', {\n            'type': 'geojson',\n            'data': sources.clusterBoundaries\n        });\n        if (sources.allEdges) {\n            map.addSource('all_edges_source', {\n                'type': 'geojson',\n                'data': sources.allEdges\n            });\n        }\n    }\n\n    addClusters(): void {\n        const { map, clusters } = this;\n        map.addLayer({\n            'id': 'cluster',\n            'type': 'fill',\n            'source': 'cluster_source',\n            'layout': {},\n            'paint': {\n                'fill-color': ['get', 'fill'],\n                'fill-opacity': clusters.fillOpacity,\n                'fill-outline-color': ['get', 'stroke']\n            }\n        });\n\n        map.addLayer({\n            'id': 'cluster_boundary',\n            'type': 'line',\n            'minzoom': clusters.borderLineMinZoom,\n            'source': 'cluster_boundary_source',\n            'layout': {},\n            'paint': {\n                'line-color': ['get', 'stroke'],\n                'line-width': clusters.borderLineWidth,\n                'line-opacity': clusters.borderLineOpacity\n            },\n        });\n    }\n\n    addEdges(): void {\n        const { map, edges, sources, maxZoom } = this;\n        const currentZoom: number = this.getZoom();\n        const edge = ['at', ['get', 'level'], ['literal', edges]];\n        const lastEdge = ['at', edges.length - 1, ['literal', edges]];\n\n        map.addLayer({\n            'id': 'edges',\n            'type': 'line',\n            'source': 'edges_source',\n            'layout': {},\n            'paint': {\n                'line-color': ['case',\n                    ['boolean', ['feature-state', 'hover'], false], 'red',\n                    ['get', 'color', edge]\n                ],\n                'line-width': ['get', 'width', edge],\n                'line-opacity': ['get', 'opacity', edge]\n            },\n            'filter': ['>=', currentZoom, ['get', 'zoom', edge]]\n        });\n        map.addLayer({\n            'id': 'edges_border',\n            'type': 'line',\n            'source': 'edges_source',\n            'layout': {},\n            'paint': {\n                'line-color': ['get', 'borderColor', edge],\n                'line-width': ['get', 'borderWidth', edge],\n                'line-opacity': ['get', 'borderOpacity', edge],\n                'line-gap-width': ['get', 'width', edge],\n            },\n            'filter': ['>=', currentZoom, ['get', 'zoom', edge]]\n        });\n\n        if (sources.allEdges) {\n            map.addLayer({\n                'id': 'all_edges',\n                'type': 'line',\n                'source': 'all_edges_source',\n                'layout': {},\n                'paint': {\n                    'line-color': ['get', 'borderColor', lastEdge],\n                    'line-width': ['get', 'borderWidth', lastEdge],\n                    'line-opacity': ['get', 'borderOpacity', lastEdge],\n                    'line-gap-width': ['get', 'width', lastEdge],\n                },\n                'minzoom': maxZoom\n            });\n        }\n    }\n\n    addNodes(): void {\n        const { map, nodes, edges } = this;\n        const currentNode: Array<any> = ['at', ['get', 'level'], ['literal', nodes]];\n        const currentEdge: Array<any> = ['get', 'zoom', ['at', ['get', 'level'], ['literal', edges]]];\n        const currentZoom: number = this.getZoom();\n\n        const nodeLabelsLayer: mapboxgl.Layer | any = {\n            'id': 'node_labels',\n            'type': 'symbol',\n            'source': 'nodes_source',\n            'layout': {\n                'text-field': '{label}',\n                'text-font': ['Open Sans Regular'],\n                'text-size': ['get', 'fontSize', currentNode],\n                'text-variable-anchor': ['top', 'bottom', 'top-left', 'top-right', 'bottom-left', 'bottom-right', 'left', 'right', 'center'],\n                'text-radial-offset': 0.25,\n                'text-justify': 'auto',\n                'text-allow-overlap': false\n            },\n            'filter': ['>=', currentZoom, ['get', 'zoom', currentNode]]\n        };\n        const nodesLayer: mapboxgl.Layer = {\n            'id': 'nodes',\n            'type': 'circle',\n            'source': 'nodes_source',\n            'layout': {},\n            'paint': {\n                'circle-color': ['case',\n                    ['boolean', ['feature-state', 'hover'], false], 'red',\n                    'black'\n                ],\n                'circle-radius': 3\n            },\n            'filter': ['>=', currentZoom, currentEdge]\n        };\n\n        map.addLayer(nodeLabelsLayer);\n        map.addLayer(nodesLayer);\n    }\n\n    addEdgeHover(): void {\n        const map: mapboxgl.Map = this.map;\n        map.on('mousemove', 'edges', function (e) {\n            // When the mouse moves, check if the mouse is on top of a feature from the edges source.\n            if (e.features.length > 0) {\n                // If there was already an edge with the hover status, turn that hover status off first\n                if (this.hoverEdgeID) {\n                    map.setFeatureState(\n                        { source: 'edges_source', id: this.hoverEdgeID },\n                        { hover: false }\n                    );\n                }\n                // Set the hover status of the new edge to true, and save the ID to the object so we can compare\n                // later, when the mouse moves again.\n                this.hoverEdgeID = e.features[0].id;\n                map.setFeatureState(\n                    { source: 'edges_source', id: this.hoverEdgeID },\n                    { hover: true }\n                );\n            }\n        });\n\n        map.on('mouseleave', 'edges', function () {\n            // When the mouse leaves the edge source features, turn the hover status off\n            if (this.hoverEdgeID) {\n                map.setFeatureState(\n                    { source: 'edges_source', id: this.hoverEdgeID },\n                    { hover: false }\n                );\n            }\n            this.hoverEdgeID = null;\n        });\n    }\n\n    addNodeHover(): void {\n        const map: mapboxgl.Map = this.map;\n        map.on('mousemove', 'nodes', function (e) {\n            // When the mouse moves, check if the mouse is on top of a feature from the nodes source.\n            if (e.features.length > 0) {\n                // If there was already an node with the hover status, turn that hover status off first\n                if (this.hoverNodeID) {\n                    map.setFeatureState(\n                        { source: 'nodes_source', id: this.hoverNodeID },\n                        { hover: false }\n                    );\n                }\n                // Set the hover status of the new node to true, and save the ID to the object so we can compare\n                // later, when the mouse moves again.\n                this.hoverNodeID = e.features[0].id;\n                map.setFeatureState(\n                    { source: 'nodes_source', id: this.hoverNodeID },\n                    { hover: true }\n                );\n            }\n        });\n\n        map.on('mouseleave', 'nodes', function () {\n            // When the mouse leaves the edge source features, turn the hover status off\n            if (this.hoverNodeID) {\n                map.setFeatureState(\n                    { source: 'nodes_source', id: this.hoverNodeID },\n                    { hover: false }\n                );\n            }\n            this.hoverNodeID = null;\n        });\n    }\n\n    addPopups(): void {\n        this.popups.forEach(popup => {\n            this.addPopupOnClick(popup.layer, popup.content)\n        });\n    }\n\n    addPopupOnClick(layer: string, content: PopupContent): void {\n        const { map } = this;\n        // When a click event occurs on a feature in the places layer, open a popup at the\n        // location of the feature, with description HTML from its properties.\n        map.on('click', layer, function (e) {\n            let descriptionHTML = createPopupHTML(e.features[0].properties, content);\n            new mapboxgl.Popup()\n                .setLngLat(e.lngLat)\n                .setHTML(descriptionHTML)\n                .addTo(map);\n        });\n\n        // Change the cursor to a pointer when the mouse is over the places layer.\n        map.on('mouseenter', layer, function () {\n            map.getCanvas().style.cursor = 'pointer';\n        });\n\n        // Change it back to a pointer when it leaves.\n        map.on('mouseleave', layer, function () {\n            map.getCanvas().style.cursor = '';\n        });\n    }\n\n    // Get the full mapbox zoom number.\n    getZoom(): number {\n        return this.map.getZoom();\n    }\n}\n\n// Takes the description field of the element, and uses it with the popup content defined in the config object\n// to return the concatenated html string.\nfunction createPopupHTML(description: object, content: PopupContent): string {\n    let html: string = '';\n    content.forEach((element, index) => {\n        if (!element) return;\n        // The config object for popups is structued like ['<html>', 'propertyName', '</html>]\n        // so on even indexes, we just concatenate the html string, on odd indexes we use the string to lookup the property value.\n        if (isEven(index)) html += element;\n\n        // Along with property values, you can pass along a formatting function in form of ['propertyName', function]\n        // This checks if there is one, if there is it uses that function to format the value of the property before\n        // concatenating it.\n        else if (typeof (element) === 'string') html += description[element];\n        else html += element[1](description[element[0]]);\n    });\n\n    return html;\n}\n\nfunction isEven(index: number): boolean {\n    return index % 2 === 0;\n}\n\n// Bind the ZmltMap to the window so that it is accessible in the main index.html file.\nglobalThis.ZmltMap = ZmltMap;\n"]}